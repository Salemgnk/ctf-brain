use crate::models::CtfBox;
use anyhow::{Context, Result};
use std::fs;
use std::path::PathBuf;

/// Get the base directory for ctf-brain data
fn get_base_dir() -> Result<PathBuf> {
    let base = dirs::home_dir()
        .context("Unable to determine home directory")?
        .join(".ctf-brain");

    fs::create_dir_all(&base).context("Failed to create .ctf-brain directory")?;

    Ok(base)
}

/// Create or update the environment file for a specific box
pub fn create_box_environment(ctf_box: &CtfBox) -> Result<()> {
    let base_dir = get_base_dir()?;
    let boxes_dir = base_dir.join("boxes");
    fs::create_dir_all(&boxes_dir).context("Failed to create boxes directory")?;

    let env_file = boxes_dir.join(format!("box-{}.env", ctf_box.id));

    // Generate custom variables exports
    let custom_vars = ctf_box
        .env_vars
        .iter()
        .map(|(key, value)| {
            // Escape double quotes in value
            let escaped_value = value.replace("\"", "\\\"");
            format!("export {}=\"{}\"", key, escaped_value)
        })
        .collect::<Vec<_>>()
        .join("\n");

    // Generate display of custom variables for welcome message
    let custom_vars_display = if ctf_box.env_vars.is_empty() {
        String::new()
    } else {
        let vars_list = ctf_box
            .env_vars
            .iter()
            .map(|(k, v)| {
                let display_val = if v.len() > 40 {
                    format!("{}...", &v[..40])
                } else {
                    v.clone()
                };
                format!("echo \"  {} = {}\"", k, display_val)
            })
            .collect::<Vec<_>>()
            .join("\n");

        format!("\necho \"üîß Custom Variables:\"\n{}\necho \"\"", vars_list)
    };

    let content = format!(
        r#"#!/bin/bash
# Auto-generated by ctf-brain for: {}
# Do not edit manually - changes will be overwritten

# ========== CTF Box Info ==========
export CTF_BOX="{}"
export CTF_IP="{}"
export CTF_ID="{}"
export CTF_PLATFORM="{}"

# ========== Custom Variables ==========
{}

# ========== Logging Hook ==========
if [ -f ~/.ctf-brain/shell-hook.sh ]; then
    source ~/.ctf-brain/shell-hook.sh
fi

# ========== Custom Prompt ==========
if [ -n "$ZSH_VERSION" ]; then
    PROMPT="%F{{green}}[üß† {}]%f %n@%m:%~%# "
else
    PS1="\[\e[32m\][üß† {}]\[\e[0m\] \u@\h:\w\$ "
fi

# ========== Quick Aliases ==========
alias ip='echo $CTF_IP'
alias n='nmap -sV $CTF_IP'
alias na='nmap -sC -sV -A $CTF_IP'
alias g='gobuster dir -u http://$CTF_IP -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt'
alias nc-listen='rlwrap nc -lvnp 4444'

# ========== Welcome Message ==========
clear
echo ""
echo "üéØ CTF Box: {}"
echo "üì° IP: {}"
echo "üè∑Ô∏è  Platform: {}"
echo "üîñ Tags: {}"
{}
echo ""
echo "üìù Pour capturer une commande avec son output:"
echo "   \033[33mctf <commande>\033[0m  ‚Üí  Ex: ctf nmap -sV \$CTF_IP"
echo ""
echo "‚ö° Raccourcis (avec capture):"
echo "   cn   ‚Üí ctf nmap -sV \$CTF_IP"
echo "   cna  ‚Üí ctf nmap -sC -sV -A \$CTF_IP"
echo "   cg   ‚Üí ctf gobuster dir ..."
echo "   cff  ‚Üí ctf ffuf ..."
echo ""
echo "üîß Autres aliases:"
echo "   ip        ‚Üí Affiche \$CTF_IP"
echo "   nc-listen ‚Üí rlwrap nc -lvnp 4444"
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üíæ Les commandes 'ctf' sont logg√©es pour le write-up"
echo "‚ö†Ô∏è  Tapez 'exit' pour revenir √† CTF Brain"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""
"#,
        ctf_box.title,
        ctf_box.title,
        ctf_box.ip_address,
        ctf_box.id,
        ctf_box.platform,
        custom_vars,
        ctf_box.title,
        ctf_box.title,
        ctf_box.title,
        ctf_box.ip_address,
        ctf_box.platform,
        ctf_box.tags.join(", "),
        custom_vars_display
    );

    fs::write(&env_file, content).context("Failed to write environment file")?;

    Ok(())
}

/// Ensure the shell hook script is installed
pub fn ensure_shell_hook_installed() -> Result<()> {
    let base_dir = get_base_dir()?;
    let hook_path = base_dir.join("shell-hook.sh");

    // Create logs directory
    let logs_dir = base_dir.join("logs");
    fs::create_dir_all(&logs_dir).context("Failed to create logs directory")?;

    // Always update the hook to get latest features
    let hook_content = r#"#!/bin/bash
# CTF Brain - Shell Hook for Command Logging
# This script captures commands and their outputs

# ========== CTF Command Wrapper ==========
# Usage: ctf <command>
# This captures the command, its output, and exit code
ctf() {
    if [ -z "$1" ]; then
        echo "Usage: ctf <command>"
        echo "Example: ctf nmap -sV \$CTF_IP"
        return 1
    fi
    
    # Ensure logs directory exists
    mkdir -p "$HOME/.ctf-brain/logs"
    
    local timestamp=$(date -Iseconds)
    local log_file="$HOME/.ctf-brain/logs/box-${CTF_ID}.jsonl"
    local tmp_output=$(mktemp)
    
    # Run the command and capture output
    echo -e "\033[36m[CTF] Running: $*\033[0m"
    echo ""
    
    # Execute and capture both stdout and stderr, while also displaying
    "$@" 2>&1 | tee "$tmp_output"
    local exit_code=${PIPESTATUS[0]}
    
    # Determine result
    local result="unknown"
    if [ $exit_code -eq 0 ]; then
        result="success"
    else
        result="fail"
    fi
    
    # Read output and escape for JSON
    local output=$(cat "$tmp_output" | head -c 50000 | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))' 2>/dev/null || echo '""')
    
    # Escape the command for JSON
    local cmd_escaped=$(echo "$*" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read().strip()))' 2>/dev/null || echo "\"$*\"")
    
    # Log in JSONL format with output
    echo "{\"time\":\"$timestamp\",\"box_id\":$CTF_ID,\"cmd\":$cmd_escaped,\"result\":\"$result\",\"exit_code\":$exit_code,\"output\":$output}" >> "$log_file"
    
    # Cleanup
    rm -f "$tmp_output"
    
    echo ""
    if [ $exit_code -eq 0 ]; then
        echo -e "\033[32m[CTF] ‚úì Command logged (success)\033[0m"
    else
        echo -e "\033[31m[CTF] ‚úó Command logged (exit code: $exit_code)\033[0m"
    fi
    
    return $exit_code
}

# ========== Quick CTF aliases ==========
# These automatically use the ctf wrapper
alias cn='ctf nmap -sV $CTF_IP'
alias cna='ctf nmap -sC -sV -A $CTF_IP'
alias cg='ctf gobuster dir -u http://$CTF_IP -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt'
alias cff='ctf ffuf -u http://$CTF_IP/FUZZ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt'

# ========== Auto-log important commands ==========
_ctf_log_command() {
    [ -z "$1" ] && return
    
    # Only log certain commands automatically (without output)
    case "$1" in
        nmap*|gobuster*|ffuf*|nikto*|sqlmap*|hydra*|john*|hashcat*|msfconsole*|searchsploit*)
            mkdir -p "$HOME/.ctf-brain/logs"
            local timestamp=$(date -Iseconds)
            local log_file="$HOME/.ctf-brain/logs/box-${CTF_ID}.jsonl"
            local cmd_escaped=$(echo "$1" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read().strip()))' 2>/dev/null || echo "\"$1\"")
            echo "{\"time\":\"$timestamp\",\"box_id\":$CTF_ID,\"cmd\":$cmd_escaped,\"result\":\"unknown\",\"auto\":true}" >> "$log_file"
            ;;
    esac
}

# Hook for Zsh
if [ -n "$ZSH_VERSION" ]; then
    preexec() {
        _ctf_log_command "$1"
    }
fi

# Hook for Bash
if [ -n "$BASH_VERSION" ]; then
    trap '_ctf_last_command=$BASH_COMMAND' DEBUG
    _ctf_prompt_command() {
        local exit_code=$?
        if [ -n "$_ctf_last_command" ]; then
            _ctf_log_command "$_ctf_last_command"
        fi
    }
    if [[ ! "$PROMPT_COMMAND" =~ "_ctf_prompt_command" ]]; then
        PROMPT_COMMAND="_ctf_prompt_command${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
    fi
fi
"#;

    fs::write(&hook_path, hook_content).context("Failed to write shell hook")?;

    // Make it executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&hook_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms)?;
    }

    Ok(())
}
