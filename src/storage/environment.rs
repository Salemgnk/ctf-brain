use crate::models::CtfBox;
use anyhow::{Context, Result};
use std::fs;
use std::path::PathBuf;

/// Get the base directory for ctf-brain data
fn get_base_dir() -> Result<PathBuf> {
    let base = dirs::home_dir()
        .context("Unable to determine home directory")?
        .join(".ctf-brain");

    fs::create_dir_all(&base).context("Failed to create .ctf-brain directory")?;

    Ok(base)
}

/// Create or update the environment file for a specific box
pub fn create_box_environment(ctf_box: &CtfBox) -> Result<()> {
    let base_dir = get_base_dir()?;
    let boxes_dir = base_dir.join("boxes");
    fs::create_dir_all(&boxes_dir).context("Failed to create boxes directory")?;

    let env_file = boxes_dir.join(format!("box-{}.env", ctf_box.id));

    // Generate custom variables exports
    let custom_vars = ctf_box
        .env_vars
        .iter()
        .map(|(key, value)| {
            // Escape double quotes in value
            let escaped_value = value.replace("\"", "\\\"");
            format!("export {}=\"{}\"", key, escaped_value)
        })
        .collect::<Vec<_>>()
        .join("\n");

    // Generate display of custom variables for welcome message
    let custom_vars_display = if ctf_box.env_vars.is_empty() {
        String::new()
    } else {
        let vars_list = ctf_box
            .env_vars
            .iter()
            .map(|(k, v)| {
                let display_val = if v.len() > 40 {
                    format!("{}...", &v[..40])
                } else {
                    v.clone()
                };
                format!("  {} = {}", k, display_val)
            })
            .collect::<Vec<_>>()
            .join("\n");

        format!("\necho \"ðŸ”§ Custom Variables:\"\n{}\necho \"\"", vars_list)
    };

    let content = format!(
        r#"#!/bin/bash
# Auto-generated by ctf-brain for: {}
# Do not edit manually - changes will be overwritten

# ========== CTF Box Info ==========
export CTF_BOX="{}"
export CTF_IP="{}"
export CTF_ID="{}"
export CTF_PLATFORM="{}"

# ========== Custom Variables ==========
{}

# ========== Logging Hook ==========
if [ -f ~/.ctf-brain/shell-hook.sh ]; then
    source ~/.ctf-brain/shell-hook.sh
fi

# ========== Custom Prompt ==========
PS1="\[\e[32m\][{}]\[\e[0m\] \u@\h:\w\$ "

# ========== Quick Aliases ==========
alias ip='echo $CTF_IP'
alias n='nmap -sV $CTF_IP'
alias na='nmap -sC -sV -A $CTF_IP'
alias g='gobuster dir -u http://$CTF_IP -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt'
alias nc-listen='rlwrap nc -lvnp 4444'

# ========== Welcome Message ==========
clear
echo ""
echo "ðŸŽ¯ CTF Box: {}"
echo "ðŸ“¡ IP: {}"
echo "ðŸ·ï¸  Platform: {}"
echo "ðŸ”– Tags: {}"
{}
echo "Commandes rapides:"
echo "  ip         â†’ Affiche l'IP"
echo "  n          â†’ nmap -sV \$CTF_IP"
echo "  na         â†’ nmap complet (sC, sV, A)"
echo "  g /path    â†’ gobuster sur \$CTF_IP"
echo "  nc-listen  â†’ rlwrap nc -lvnp 4444"
echo ""
echo "ðŸ’¾ Toutes les commandes sont loggÃ©es automatiquement"
echo ""
"#,
        ctf_box.title,
        ctf_box.title,
        ctf_box.ip_address,
        ctf_box.id,
        ctf_box.platform,
        custom_vars,
        ctf_box.title,
        ctf_box.title,
        ctf_box.ip_address,
        ctf_box.platform,
        ctf_box.tags.join(", "),
        custom_vars_display
    );

    fs::write(&env_file, content).context("Failed to write environment file")?;

    Ok(())
}

/// Ensure the shell hook script is installed
pub fn ensure_shell_hook_installed() -> Result<()> {
    let base_dir = get_base_dir()?;
    let hook_path = base_dir.join("shell-hook.sh");

    // Don't overwrite if it already exists
    if hook_path.exists() {
        return Ok(());
    }

    // Create logs directory
    let logs_dir = base_dir.join("logs");
    fs::create_dir_all(&logs_dir).context("Failed to create logs directory")?;

    let hook_content = r#"#!/bin/bash
# CTF Brain - Shell Hook for Command Logging
# This script captures all commands and logs them to JSONL files

_ctf_log_command() {
    # Ignore empty commands
    [ -z "$1" ] && return
    
    # Ignore internal commands to reduce noise
    case "$1" in
        cd|cd\ *|ls|ls\ *|pwd|clear|exit|history) return ;;
    esac
    
    # Ensure logs directory exists
    mkdir -p "$HOME/.ctf-brain/logs"
    
    # Log in JSONL format
    local timestamp=$(date -Iseconds)
    local log_file="$HOME/.ctf-brain/logs/box-${CTF_ID}.jsonl"
    
    # Escape double quotes in command
    local cmd_escaped=$(echo "$1" | sed 's/"/\\"/g')
    
    echo "{\"time\":\"$timestamp\",\"box_id\":$CTF_ID,\"cmd\":\"$cmd_escaped\"}" >> "$log_file"
}

# Hook for Bash
if [ -n "$BASH_VERSION" ]; then
    # Save the previous command
    trap '_previous_command=$_this_command; _this_command=$BASH_COMMAND' DEBUG
    
    # Log after each prompt
    _ctf_prompt_command() {
        local exit_code=$?
        if [ -n "$_previous_command" ]; then
            _ctf_log_command "$_previous_command"
        fi
    }
    
    # Append to existing PROMPT_COMMAND
    if [ -n "$PROMPT_COMMAND" ]; then
        PROMPT_COMMAND="_ctf_prompt_command; $PROMPT_COMMAND"
    else
        PROMPT_COMMAND="_ctf_prompt_command"
    fi
fi

# Hook for Zsh (if user uses zsh)
if [ -n "$ZSH_VERSION" ]; then
    preexec() {
        _ctf_log_command "$1"
    }
fi
"#;

    fs::write(&hook_path, hook_content).context("Failed to write shell hook")?;

    // Make it executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&hook_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms)?;
    }

    Ok(())
}
